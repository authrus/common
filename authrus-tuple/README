Grid Predicate System

A fundamental part of any messaging system is the ability to choose which messages to receive and which ones to ignore. For example, in Tibco Rendezvous there is a primitive filtering system based on a topic. The puropse of the topic is the construct a hierarchy of channels that can be listened to. Such a topic typically represented by a dot (.) delimited string of tokens. Below are some examples.

"FUTURE.YBX.MAR"
"BOND.AU3FN0000345.INDICATIVE"
"BOND.AU3FN0000345.CLOSE"

Taking these examples you could listen to close prices by subscribing to "BOND.*.CLOSE" or you could listen to all messages for a specific bond by subscribing to "BOND.AU3FN0000345.*". You are however limited by the tokens in the topic, in such a scenario you could not subscribe to messages from a specific user, company or perhaps product type. A better alternative is to use a predicate system that can filter messages based on user specified criteria, by simply evaluating the attributes of a message. Such a predicate system would provide the capability for a subscriber to select very specific messages and also enables sophisticated routing schemes to be created in an ad hoc manner.

Predicate Expressions

In order to subscribe for and search for messages that match some user defined criteria an expression language is required. It enables users to compose a natural human readable statement that can be used to construct an evaluation tree. This evaluation tree can then be traversed to determine if a messages matches the desired criteria. Below is an example of such an expression. As can be seen it takes the form familiar to Java, C++, and Perl developers.

user == 'John Doe' && company = ACME && age > 30

Here we want a message that has a user attribute of 'John Doe' a company attribute of 'ACME' and age attribute greater than 30. Any such expression can be composed and the evaluation tree is similar to that of common programming languages such as Java. More complex expressions can be devised where the evaluation is performed in a nested manner. For instance lets say we wish to accept messages that match two conflicting sets of criteria. In such a scenario different operators can be used and traversal of the tree is determined using parenthesis like so.

(user == 'John Doe' && company == ACME && age > 30) || (user == 'Jane Done' && age <= 30)

Here the evaluation of the expression considers the first expression within parenthesis, if it is successful then the expression evaluates to true, if not the second expression is evaluated. As much nesting as desired can be performed.

((((user == 'John Doe') || (user == 'Jane Doe')) && company == 'ACME) || age == 40) && status == 'VALID'

Lexical Analysis

The predicate expressions use a very simple lexer where the attribute name is any sequence of characters with or without enclosing quotes. The operator must be one of a predefined set that closely match Java and Perl operators. Finally the value token to be evaluated can be any sequence of characters be with or without enclosing quotes, a string without quotes that consists of only digits, or a minus sign, or a period will be considered a decimal. Here are some examples.

'John Doe': Evaluated as the string "John Doe"
ACME: Evaluated as the string "ACME"
"Error occurred": Evaluated as the string "Error occured"
"VALID": Evaluated as the string "VALID"
tom@company.com: Evaluated to string "tom@company.com"
30: Evaluated as the number 30.0
"55": Evaluated as the string "55"
40.67: Evaluated as the number 40.67
-1.4: Evaluated as the number -1.4
+235: Evaluated as the string "+235"
'list[10]': Evaluated to the string "list[10]"
"map{'blah'}": Evaluated to the string "map('blah'}"
Jane Doe: Evaluated to two tokens and is an error
table{'key'}: Evaluated as an error as it uses illegal characters
<blah>: Evaluated as an error as it uses illegal characters

Any double quoted strings can be escaped by wrapping them in single quotes and single quoted strings can be escaped by wrapping them in double quotes. To clarify here are some statements using the rules defined above.

user == John
user == 'John Doe'
user == "John O'Brien"
"user[1]" == John
"user{'actor'} == "Peter O'Toole"
age == e in Backus Naur Form.
age > 70.5
person.name == Tom
company.employee.status == SICK
#some.attribute == "blah"
name@group == "Some Group"
.mail == some.person@company.com

Expression Grammar

To further clarify here is the grammar used to process the tokens and build the evaluation tree in Backus Naur Form.

predicate ::= expression | compound-expression
expression ::= statement *(condition statement)
compound-expression ::= "(" *expression | *compound-expression ")"
statement ::= condition-statement *(operator condition-statement)
compound-statement ::= "(" *statement | *compound-statement ")"
condition-statement ::= text operator text | "*"
text ::= token | quoted-token | number
token ::= *( alphanumeric | "@" | "." | "#" )
number ::= negative-decimal | decimal 
negative-decimal ::= "-" decimal
decimal ::= *number | *number "." *number
quoted-token ::= single-quote-token | double-quote-token
single-quote-token ::= single-quote single-quote-text single-quote 
double-quote-token ::= double-quote double-quote-text double-quote
single-quote-text ::= *text | *double-quote
double-quote-text ::= *text | *single-quote 
single-quote ::= "'"
double-quote ::= """
condition ::= "&&" | "||" | "!"
operator ::= "<" | ">" | "<=" | ">=" | "==" | "!=" | "=~"



